var fs = require('fs');
var yaml = require('yamlparser');
var url = require('url');

var CONTENT_TYPE = 'Content-Type';
var CONTENT_TYPES = {
    '.css': 'text/css',
    '.gif': 'image/gif',
    '.htm': 'text/html',
    '.html': 'text/html',
    '.ico': 'image/x-icon',
    '.jpeg': 'image/jpeg',
    '.jpg': 'image/jpeg',
    '.js': 'application/javascript',
    '.json': 'application/json',
    '.manifest': 'text/cache-manifest',
    '.png': 'image/png',
    '.txt': 'text/plain',
}

////////////////////////////////////////////////////////////////////////////
// UTILITIES

/**
 * split raw data into header and body.
 */
function split(rawData) {
    var entry = {headObj: null, bodyData: rawData};
    var headStart = rawData.indexOf('---');
    if (headStart >= 0) {
        var headEnd = rawData.indexOf('---\n', headStart + 3);
        if (headEnd >= 0) {
            headStr = rawData.substring(headStart, headEnd);
            entry.headObj = yaml.eval(headStr);
            entry.bodyData = rawData.substring(headEnd + 4);
        }
    }
    return entry;
}

function extractExt(path) {
    // Determine content type.
    return path.toLowerCase().match('\.[^.]*$');
}

////////////////////////////////////////////////////////////////////////////
// CONTENT

function Content(path) {
    this._path = path;
    this._onsuccessCallback = null;
    this._onerrorCallback = null;
    this._rawData = '';

    return this;
}

Content.prototype.readAll = function(onsuccess, onerror) {
    var self = this;
    self._onsuccessCallback = onsuccess;
    self._onerrorCallback = onerror;
    var reader = fs.createReadStream(self._path);
    reader.on('error', function(e) { self._onerror(e); });
    reader.on('end', function() { self._onend(); });
    reader.on('data', function(data) { self._ondata(data); });
}

Content.prototype._ondata = function(data) {
    // FIXME: redirect to the response object for speed.
    this._rawData += data;
}

Content.prototype._onend = function() {
    // split head and body.
    try {
        var entry = split(this._rawData);
    } catch (e) {
        console.log('invalid data: ' + e);
        // FIXME: build an entry for error.
    }

    // setup default response values.
    var statusCode = 200;
    var contentType = CONTENT_TYPES[extractExt(this._path)];
    if (!contentType) {
        contentType = 'text/plain';
    }

    // FIXME: support more elements in header.
    if (entry.headObj) {
        if (CONTENT_TYPE in entry.headObj) {
            contentType = entry.headObj[CONTENT_TYPE];
        }
    }

    if (this._onsuccessCallback) {
        var header = {
            'Content-Type': contentType,
        };
        this._onsuccessCallback(statusCode, header, entry.bodyData);
    }
}

Content.prototype._onerror = function(exception) {
    // FIXME: logging in proper way.
    console.log('Content#_onerror ' + exception);
    if (this._onerrorCallback) {
        // FIXME: log exception.
        this._onerrorCallback();
    }
}

////////////////////////////////////////////////////////////////////////////
// CONTEXT

function Context() {
    this.htdocsDir = './htdocs';
    return this;
}

Context.prototype.handle = function(req, res) {
    var self = this;
    this._dispatch(req, res, function(target) {
        if (target) {
            self._render(target.path, req, res);
        } else {
            res.writeHead(404, {'Context-Type': 'text/html'});
            res.end('<h1>404 Not found</h1>\n');
        }
    });
}

Context.prototype._dispatch = function(req, res, callback) {
    // choice correct object by path.
    var key = url.parse(req.url).pathname.split('/').filter(function(item) {
        return item && item.length > 0;
    });

    // FIXME: combine options, cache fs stats results.
    var options = {};
    key.unshift('./htdocs');
    var path = key.join('/');

    fs.stat(path, function(err, stats){
        if (!stats) {
            callback(null);
        } else if (stats.isDirectory()) {
            callback({path: path + '/_folder', options: options});
        } else {
            callback({path: path, options: options});
        }
    });
}

Context.prototype._render = function(path, req, res) {
    var content = new Content(path);
    content.readAll(function(status, header, body) {
        res.writeHead(status, header, body);
        res.write(body);
        res.end();
    }, function() {
        res.writeHead(500, {CONTENT_TYPE: 'text/html'});
        res.end('<h1>500 Internal server error</h1>\n');
    });
}

////////////////////////////////////////////////////////////////////////////
// MODULE EXPORTS

module.exports = Context;
// vim:set ts=8 sts=4 sw=4 tw=0 et:
