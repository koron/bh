var fs = require('fs');
var yaml = require('yamlparser');

var CONTENT_TYPE = 'Content-Type';

////////////////////////////////////////////////////////////////////////////
// CONTENT

function Content(path) {
    this._path = path;
    this._onsuccessCallback = null;
    this._onerrorCallback = null;
    this._body = '';

    return this;
}

Content.prototype.readAll = function(onsuccess, onerror) {
    var self = this;
    self._onsuccessCallback = onsuccess;
    self._onerrorCallback
    var reader = fs.createReadStream(self._path);
    reader.on('error', function(e) { self._onerror(e); });
    reader.on('end', function() { self._onend(); });
    reader.on('data', function(data) { self._ondata(data); });
}

Content.prototype._ondata = function(data) {
    // FIXME: redirect to the response object for speed.
    this._body += data;
}

Content.prototype._onend = function() {
    // split head and body.
    var headObj;
    var headStr;
    var bodyStr = this._body;
    var headStart = this._body.indexOf('---');
    if (headStart >= 0) {
        var headEnd = this._body.indexOf('---\n', headStart + 3);
        if (headEnd >= 0) {
            headStr = this._body.substring(headStart, headEnd);
            bodyStr = this._body.substring(headEnd + 4);
            try {
                var headObj = yaml.eval(headStr);
            } catch (e) {
                // FIXME: better error logging.
                console.log('YAML error: ' + e);
            }
        }
    }

    // setup default response values.
    var statusCode = 200;
    var contentType = 'text/plain';

    // FIXME: support more elements in header.
    if (headObj) {
        if (CONTENT_TYPE in headObj) {
            contentType = headObj[CONTENT_TYPE];
        }
    }

    if (this._onsuccessCallback) {
        var header = {
            'Content-Type': contentType,
        };
        this._onsuccessCallback(statusCode, header, bodyStr);
    }
}

Content.prototype._onerror = function(exception) {
    if (this._onerrorCallback) {
        // FIXME: log exception.
        this._onerrorCallback();
    }
}

////////////////////////////////////////////////////////////////////////////
// CONTEXT

function Context() {
    this.htdocsDir = './htdocs';
    return this;
}

Context.prototype.handle = function(req, res) {
    var path = this._dispatch(req, res);
    if (path) {
        this._render(path, req, res);
    } else {
        res.writeHead(404, {'Context-Type': 'text/html'});
        res.end('<h1>404 Not found</h1>');
    }
}

Context.prototype._dispatch = function(req, res) {
    // TODO: choice correct object by path.
    return './htdocs/_folder';
}

Context.prototype._render = function(path, req, res) {
    var content = new Content(path);
    content.readAll(function(status, header, body) {
        res.writeHead(status, header, body);
        res.write(body);
        res.end();
    }, function() {
        res.writeHead(500, {CONTENT_TYPE: 'text/html'});
        res.end('<h1>500 Internal server error</h1>');
    });
}

////////////////////////////////////////////////////////////////////////////
// MODULE EXPORTS

module.exports = Context;
// vim:set ts=8 sts=4 sw=4 tw=0 et:
